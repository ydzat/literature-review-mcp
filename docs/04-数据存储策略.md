# 数据存储策略分析
## 本地存储 vs Notion 存储的权衡

---

## 📊 当前存储方案分析

### 现有设计
```
WORK_DIR/
├── [arxiv_id].pdf              # PDF 原文
├── [arxiv_id]_text.txt         # 提取的文本
├── [arxiv_id]_review.md        # 生成的综述
└── ...
```

**优点**:
- ✅ 简单直接
- ✅ 用户完全控制
- ✅ 离线可用

**缺点**:
- ❌ 文件散乱，难以管理
- ❌ 无法跨设备访问
- ❌ 缺乏结构化组织
- ❌ 与 Notion 输出重复

---

## 🎯 核心问题分析

### 1. 哪些数据必须本地存储？

#### ✅ **必须本地存储**
1. **PDF 原文**
   - 原因: 需要解析提取文本，Notion 不适合存储大型 PDF
   - 用途: 文本提取、关键信息提取、来源验证
   - 大小: 通常 1-10 MB/篇

2. **提取的文本内容**
   - 原因: 作为 AI 分析的输入，需要快速访问
   - 用途: 综述生成、关键信息提取、关系分析
   - 大小: 通常 100-500 KB/篇

3. **缓存数据**
   - 原因: 避免重复调用外部 API（arXiv, DBLP, etc.）
   - 用途: 提高性能，减少 API 调用
   - 大小: 通常 10-100 KB/篇

#### ❌ **不必本地存储**
1. **生成的综述** → 直接输出到 Notion
2. **论文元数据** → 直接输出到 Notion 数据库
3. **作者/机构信息** → 直接输出到 Notion 数据库

### 2. 本地存储的必要性

**场景 1: 文献综述生成**
```
用户请求 → 下载 PDF → 提取文本 → AI 分析 → 生成综述 → 输出到 Notion
           ↓           ↓
         本地存储    本地存储
```
- **PDF 和文本必须本地存储**: 作为分析的原始材料
- **综述不必本地存储**: 直接输出到 Notion

**场景 2: 论文搜索**
```
用户请求 → 调用 API → 获取元数据 → 输出到 Notion
                      ↓
                   可选缓存
```
- **元数据可选缓存**: 提高性能，但不是必须

**场景 3: 离线使用**
```
用户请求 → 读取本地缓存 → 输出结果
```
- **缓存有价值**: 支持离线使用

---

## 💡 推荐的存储策略

### 方案 A: 混合存储（推荐）⭐⭐⭐⭐⭐

**设计原则**: 
- **本地存储**: 原始数据（PDF、文本）+ 缓存
- **Notion 存储**: 结构化知识（综述、元数据、关系）

**目录结构**:
```
~/.arxiv-mcp/                    # 用户主目录下的隐藏目录
├── cache/                       # 缓存目录
│   ├── papers/                  # 论文元数据缓存
│   │   ├── 1706.03762.json
│   │   └── ...
│   ├── authors/                 # 作者信息缓存
│   │   ├── yann_lecun.json
│   │   └── ...
│   └── api_responses/           # API 响应缓存
│       └── ...
│
├── pdfs/                        # PDF 存储
│   ├── 1706.03762.pdf
│   └── ...
│
├── texts/                       # 提取的文本
│   ├── 1706.03762.txt
│   └── ...
│
└── config.json                  # 配置文件
```

**优点**:
- ✅ 清晰的目录结构
- ✅ 隐藏目录，不干扰用户工作区
- ✅ 缓存提高性能
- ✅ PDF 和文本可重复使用
- ✅ 与 Notion 输出不冲突

**缺点**:
- ⚠️ 需要管理缓存过期
- ⚠️ 占用磁盘空间

### 方案 B: 纯临时存储 ⭐⭐⭐

**设计原则**: 
- **临时存储**: PDF 和文本仅在处理时存储，处理完删除
- **Notion 存储**: 所有结构化知识

**目录结构**:
```
/tmp/arxiv-mcp-[session-id]/     # 临时目录
├── 1706.03762.pdf
├── 1706.03762.txt
└── ...
```

**优点**:
- ✅ 不占用长期存储空间
- ✅ 自动清理

**缺点**:
- ❌ 每次都需要重新下载 PDF
- ❌ 无法离线使用
- ❌ 性能较差

### 方案 C: 用户指定工作目录（当前方案）⭐⭐

**设计原则**: 
- **用户控制**: 用户指定 WORK_DIR
- **所有数据**: PDF、文本、综述都存储在 WORK_DIR

**优点**:
- ✅ 用户完全控制
- ✅ 灵活性高

**缺点**:
- ❌ 文件散乱
- ❌ 与 Notion 输出重复
- ❌ 需要用户手动管理

---

## 🎯 推荐实施方案

### 采用 **方案 A: 混合存储**

#### 1. 目录结构
```typescript
const STORAGE_ROOT = path.join(os.homedir(), '.arxiv-mcp');

const STORAGE_PATHS = {
  root: STORAGE_ROOT,
  cache: path.join(STORAGE_ROOT, 'cache'),
  papers: path.join(STORAGE_ROOT, 'cache', 'papers'),
  authors: path.join(STORAGE_ROOT, 'cache', 'authors'),
  apiResponses: path.join(STORAGE_ROOT, 'cache', 'api_responses'),
  pdfs: path.join(STORAGE_ROOT, 'pdfs'),
  texts: path.join(STORAGE_ROOT, 'texts'),
  config: path.join(STORAGE_ROOT, 'config.json')
};
```

#### 2. 缓存策略
```typescript
interface CacheEntry<T> {
  data: T;
  timestamp: number;
  ttl: number;  // Time to live (秒)
}

class CacheManager {
  // 论文元数据缓存 - 7 天
  async cachePaperMetadata(arxivId: string, data: any): Promise<void> {
    const entry: CacheEntry<any> = {
      data,
      timestamp: Date.now(),
      ttl: 7 * 24 * 60 * 60  // 7 天
    };
    await fs.promises.writeFile(
      path.join(STORAGE_PATHS.papers, `${arxivId}.json`),
      JSON.stringify(entry, null, 2)
    );
  }
  
  // 作者信息缓存 - 30 天
  async cacheAuthorInfo(authorName: string, data: any): Promise<void> {
    const entry: CacheEntry<any> = {
      data,
      timestamp: Date.now(),
      ttl: 30 * 24 * 60 * 60  // 30 天
    };
    await fs.promises.writeFile(
      path.join(STORAGE_PATHS.authors, `${authorName}.json`),
      JSON.stringify(entry, null, 2)
    );
  }
  
  // API 响应缓存 - 1 天
  async cacheApiResponse(key: string, data: any): Promise<void> {
    const entry: CacheEntry<any> = {
      data,
      timestamp: Date.now(),
      ttl: 24 * 60 * 60  // 1 天
    };
    await fs.promises.writeFile(
      path.join(STORAGE_PATHS.apiResponses, `${key}.json`),
      JSON.stringify(entry, null, 2)
    );
  }
  
  // 检查缓存是否过期
  async isCacheValid<T>(filePath: string): Promise<boolean> {
    try {
      const content = await fs.promises.readFile(filePath, 'utf-8');
      const entry: CacheEntry<T> = JSON.parse(content);
      const age = (Date.now() - entry.timestamp) / 1000;
      return age < entry.ttl;
    } catch {
      return false;
    }
  }
}
```

#### 3. PDF 管理
```typescript
class PdfManager {
  // 下载并缓存 PDF
  async downloadPdf(arxivId: string): Promise<string> {
    const pdfPath = path.join(STORAGE_PATHS.pdfs, `${arxivId}.pdf`);
    
    // 检查是否已存在
    if (fs.existsSync(pdfPath)) {
      console.log(`✅ PDF 已缓存: ${pdfPath}`);
      return pdfPath;
    }
    
    // 下载 PDF
    console.log(`⬇️ 下载 PDF: ${arxivId}`);
    const pdfUrl = `https://arxiv.org/pdf/${arxivId}.pdf`;
    const response = await axios.get(pdfUrl, { responseType: 'arraybuffer' });
    await fs.promises.writeFile(pdfPath, response.data);
    
    return pdfPath;
  }
  
  // 提取并缓存文本
  async extractText(arxivId: string): Promise<string> {
    const textPath = path.join(STORAGE_PATHS.texts, `${arxivId}.txt`);
    
    // 检查是否已存在
    if (fs.existsSync(textPath)) {
      console.log(`✅ 文本已缓存: ${textPath}`);
      return await fs.promises.readFile(textPath, 'utf-8');
    }
    
    // 提取文本
    const pdfPath = await this.downloadPdf(arxivId);
    const text = await parsePdfToText(pdfPath);
    await fs.promises.writeFile(textPath, text);
    
    return text;
  }
  
  // 清理旧的 PDF（可选）
  async cleanOldPdfs(daysOld: number = 90): Promise<void> {
    const files = await fs.promises.readdir(STORAGE_PATHS.pdfs);
    const now = Date.now();
    
    for (const file of files) {
      const filePath = path.join(STORAGE_PATHS.pdfs, file);
      const stats = await fs.promises.stat(filePath);
      const age = (now - stats.mtimeMs) / (1000 * 60 * 60 * 24);
      
      if (age > daysOld) {
        await fs.promises.unlink(filePath);
        console.log(`🗑️ 删除旧 PDF: ${file}`);
      }
    }
  }
}
```

#### 4. 配置管理
```typescript
interface Config {
  version: string;
  cacheEnabled: boolean;
  cacheTtl: {
    papers: number;
    authors: number;
    apiResponses: number;
  };
  pdfRetentionDays: number;
  notionIntegration: {
    enabled: boolean;
    autoSync: boolean;
  };
}

const DEFAULT_CONFIG: Config = {
  version: '1.0.0',
  cacheEnabled: true,
  cacheTtl: {
    papers: 7 * 24 * 60 * 60,      // 7 天
    authors: 30 * 24 * 60 * 60,    // 30 天
    apiResponses: 24 * 60 * 60     // 1 天
  },
  pdfRetentionDays: 90,
  notionIntegration: {
    enabled: true,
    autoSync: false
  }
};
```

---

## 📋 实施步骤

### Phase 1: 迁移到新存储结构（2-3 天）
- [ ] 创建 `src/storage/` 目录
- [ ] 实现 `CacheManager` 类
- [ ] 实现 `PdfManager` 类
- [ ] 实现 `ConfigManager` 类
- [ ] 迁移现有代码到新结构

### Phase 2: 优化缓存策略（1-2 天）
- [ ] 实现缓存过期检查
- [ ] 实现缓存清理
- [ ] 添加缓存统计

### Phase 3: 测试和文档（1 天）
- [ ] 单元测试
- [ ] 集成测试
- [ ] 文档更新

**总计**: 4-6 天（约 1 周）

---

## 🎯 最终存储架构

```
本地存储 (~/.arxiv-mcp/)
├── PDF 原文（长期缓存）
├── 提取的文本（长期缓存）
└── API 响应缓存（短期缓存）

Notion 存储
├── 综述文档（结构化页面）
├── 论文数据库（元数据）
├── 作者数据库（声誉信息）
└── 机构数据库（等级信息）
```

**数据流**:
```
用户请求
  ↓
检查本地缓存
  ↓ (未命中)
下载 PDF → 本地存储
  ↓
提取文本 → 本地存储
  ↓
AI 分析
  ↓
生成结构化输出 + notion_metadata
  ↓
Agent 使用 notion_metadata → Notion
```

---

## ✅ 优势总结

### 对用户
- ✅ **透明**: 用户无需关心本地存储，自动管理
- ✅ **高效**: 缓存避免重复下载和处理
- ✅ **整洁**: 所有数据集中在 `~/.arxiv-mcp/`
- ✅ **灵活**: 可配置缓存策略

### 对系统
- ✅ **性能**: 缓存提高响应速度
- ✅ **可靠**: 离线可用（已缓存的数据）
- ✅ **可维护**: 清晰的目录结构
- ✅ **可扩展**: 易于添加新的缓存类型

---

**推荐**: 采用方案 A（混合存储），在 `~/.arxiv-mcp/` 下管理本地数据，结构化知识输出到 Notion 📚

